#!/usr/bin/env ruby

require 'nokogiri'
require 'optparse'
require 'ostruct'
require 'pathname'
require 'yaml'

class Scrivx
  attr_reader :path

  PROJECT_PROPERTIES_MAP = {
    title: 'ProjectTitle',
    abbreviated_title: 'AbbreviatedTitle',
    author_full_name: 'FullName',
    author_last_name: 'LastName',
    author_first_name: 'FirstName'
  }

  def self.scrivx(path)
    scrivener_path = Pathname(path)
    basename = scrivener_path.basename
    scrivx_path = scrivener_path / basename.sub_ext('.scrivx')

    raise "Cannot read SCRIVX file: #{scrivx_path}" unless scrivx_path.exist?

    scrivx_file = scrivx_path.open
    Scrivx.new(path: scrivener_path, scrivx: Nokogiri::XML(scrivx_file))
  end

  def self.project(scrivener_path)
    scrivx(scrivener_path).project
  end

  def initialize(path:, scrivx:)
    @path = Pathname(path)
    @scrivx = scrivx
  end

  def project
    project = OpenStruct.new(properties_from_elements(context: project_properties_node, map: PROJECT_PROPERTIES_MAP))
    project.binder = OpenStruct.new
    project.binder.children = children(context: binder_node, parent: project.binder)
    project.custom_metadata_fields = custom_metadata_fields
    project
  end

  private

  def binder_node
    @scrivx.at_xpath('.//Binder')
  end

  def children(context:, parent:)
    return [] if context.nil?
    context.xpath('./BinderItem').map do |binder_item_node|
      include = binder_item_node.at_xpath('./MetaData/IncludeInCompile')
      id = binder_item_node['ID']
      properties = {
        custom_metadata: custom_metadata(binder_item_node),
        file_path: @path / "Files/Docs/#{id}.rtf",
        id: id,
        include_in_compile?: !include.nil? && include.content == 'Yes',
        notes_path: @path / "Files/Docs/#{id}_notes.rtf",
        parent: parent,
        synopsis_path: @path / "Files/Docs/#{id}_synopsis.txt",
        title: binder_item_node.at_xpath('./Title').content,
        type: binder_item_node['Type'],
      }
      item = OpenStruct.new(properties)
      children_node = binder_item_node.at_xpath('Children')
      item.children = children(context: children_node, parent: item)
      item
    end
  end

  def custom_metadata(item)
    item.xpath('./MetaData/CustomMetaData/MetaDataItem').inject({}) do |fields, field|
      id = field.at_xpath('./FieldID').content
      value = field.at_xpath('./Value').content
      fields[id] = value
      fields
    end
  end

  def custom_metadata_fields
    @scrivx.xpath('.//CustomMetaDataSettings/MetaDataField').inject({}) do |fields, field|
      fields[field['ID']] = field.content
      fields
    end
  end

  def project_properties_node
    @scrivx.at_xpath('.//ProjectProperties')
  end

  def properties_from_elements(context:, map:)
    map.inject({}) do |properties, (property, xpath)|
      node = context.at_xpath(xpath)
      properties[property] = node.content unless node.nil?
      properties
    end
  end
end

class CommandLine
  def self.parse
    options = OpenStruct.new

    parser = OptionParser.new do |opts|
      opts.banner << ' file dir'

      opts.on_tail('-h', '--help', 'print this message') do
        puts opts
        exit
      end
    end

    parser.parse! ARGV

    unless ARGV.length == 2
      puts parser
      exit
    end

    options.scrivener_file = Pathname(ARGV[0])
    options.book_dir = Pathname(ARGV[1])

    unless options.scrivener_file.directory?
      puts "No such Scrivener file: #{options.scrivener_file}"
      exit
    end

    options
  end
end

class Document
  def initialize(parent:, binder:)
    @parent = parent
    @binder = binder
  end

  def children(parent:)
    parent.children.flat_map do |item|
      items = []
      items << path(item) if item.include_in_compile?
      items + children(parent: item)
    end
  end

  def depth(item)
    item.equal?(@binder) ? -1 : depth(item.parent) + 1
  end

  def doc_id(item)
    "#{item.id}"
  end

  def path(item)
    "#{trail(item)}.html"
  end

  def properties(item)
    {
      'title' => item.title,
      'type' => item.type,
      'doc_id' => doc_id(item),
      'depth' => depth(item),
    }.merge item.custom_metadata
  end

  def slug(item)
    # Convert each sequence of whitespace characters to a single hyphen.
    # Delete each non-alphanumeric character (except hyphen).
    # Convert the whole thing to lower case.
    item.title.gsub(/\s+/, '-').gsub(/[^[:alnum:]-]/, '').downcase
  end

  def trail(item)
    depth(item) == 0 ? Pathname('content') : trail(item.parent) / slug(item)
  end
end

class Book
  attr_reader :publication, :author, :spine

  def initialize(project)
    @project = project
    @publication = publication
    @author = author
    @spine = children(parent: project.binder.children.first)
  end

  def author
    sort = []
    sort << @project.author_last_name unless @project.author_last_name.empty?
    sort << @project.author_first_name unless @project.author_first_name.empty?

    name = @project.author_full_name unless @project.author_full_name.empty?
    name ||= sort.reverse.join(' ') unless sort.empty?
    return name if sort.empty?
    { 'name' => name, 'sort' => sort.join(', ')}
  end

  def publication
    {
      'title' => @project.title,
    }
  end
end

class Writer
  def initialize(book:, dir:, project:)
    @book = book
    @dir = dir
    @project = project
  end

  def write
    @dir.mkpath
    write_book
    write_markdown_files
  end

  private

  def write_book
    data_dir = @dir / '_data'
    data_dir.mkpath
    publication_file = data_dir / '_publication.yaml'
    publication_file.write(@book.publication.to_yaml)
    author_file = data_dir / '_author.yaml'
    author_file.write(@book.author.to_yaml)
    spine_file = data_dir / '_spine.yaml'
    spine_file.write(@book.spine.to_yaml)
  end

  def write_markdown_files
    @project.binder.children.first.children.each do |item|
      write_file(dir: @dir, item: item)
    end
  end

  def to_markdown(item)
    rtf_path = item.file_path
    return nil unless rtf_path.file?
    %x{ textutil -convert html -excludedelements '(span)' -strip -stdout #{rtf_path} | pandoc -f html -t markdown }
  end

  def write_file(dir:, item:)
    item.children.each{ |child| write_file(dir: dir, item: child)}
    return unless item.include_in_compile?
    content = StringIO.new
    content.puts properties(item).to_yaml
    content.puts '...'
    content.puts to_markdown(item)
    file = dir / path(item)
    file.parent.mkpath
    file.write(content.string)
  end
end

options = CommandLine.parse

scrivener_file = options.scrivener_file
book_dir = options.book_dir

project = Scrivx.project(scrivener_file)
book = Book.new(project)
writer = Writer.new(book: book, dir: book_dir, project: project)
writer.write
